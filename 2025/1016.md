# 【React】「とりあえず切り出す」をやめる - カスタムフック設計で大事なこと を読む

https://zenn.dev/uzu_tech/articles/12bb1dde240c5b

## カスタムフックにおける 3 つの原則

1. 単一責任: 1 つのフックは 1 つのことをする
2. 直感的な API: 使いやすいインターフェース設計
3. パフォーマンス: 適切な最適化の判断基準

## カスタムフックを作るべきタイミング

1. 同じロジックを複数箇所で使っている時: 重複を避けて再利用する
2. コンポーネントのロジックが複雑になってきた時: ロジックと UI を分離してシンプルに保つ
3. 副作用を適切に管理したい時: API 呼び出しやイベントリスナーなどをカプセル化

## アンチパターン

- 1 箇所でしか使わないロジック - まずはコンポーネント内に書く。必要になってから切り出す
- 単純な計算や変換 - 普通の関数で十分

コードが長くなったから、カスタムフックに切り出す アプローチは、本来の趣旨から外れている
ロジックの再利用性や咳部の分離を重視し、単なるコード分割に終わらせない

## 単一責任

- ユーザ情報だけ欲しいが、テーマやモーダルの状態なども一緒についてくる
  このようなカスタムフックは責務が多く、問題である

良い設計

- トグル状態の管理 といった一つの明確な責務だけを持つものにする
- どこでも再利用が可能

判断基準

- このフックは〇〇をする と一言で説明できること
  - 説明に「と」「や」が入るなら、分割を検討したい

## 直下的な API

カスタムフックの API は、一貫性があり、予測可能であるべき
React の標準フック（useState、useReducer など）の形式に合わせることで、使い方が予測しやすくなる

### 配列形式 `useState` スタイル

- シンプルに、1 つの値とその更新関数を返す

```
const [value, setValue] = useLocalStorage('key', initialValue);
```

### オブジェクト形式 複数の値を返す場合

- 返り値が多い場合、名前で認識できわかりやすい

```
const { data, error, isLoading, refetch } = useQuery(url);
```

### ハンドラの分離 状態と操作を明確に区別

```
const [items, { add, remove, clear }] = useArray([]);
```

値は直接参照、操作はオブジェクトにまとめ、役割が明確

一貫したパターンを使用することが重要

## パフォーマンス：カスタムフック内での最適化

### 原則 1: フックが返す関数は必ずメモ化する

カスタムフックが返す関数は、コンポーネントの再レンダリングのたびに新しい関数が生成されないよう、useCallback でメモ化すべき

フックが返す関数は、使う側のコンポーネントで useEffect の依存配列に入る可能性がある
メモ化しないと、意図しない再実行を引き起こす

### 原則 2: 重い計算が必要なら、カスタムフックに切り出す

コンポーネント内で複雑な計算やフィルタリングを行っている場合、それをカスタムフックに切り出すことで、再利用性とテスタビリティが向上する

重い計算をフックに隠蔽することで、コンポーネントがシンプルになる
useMemo による最適化もフック内部で完結
同じフィルタリングロジックを他のコンポーネントでも再利用可能

### 原則 3: 過度な最適化は避ける

カスタムフックを作る時、「将来使うかもしれない」機能を先回りして実装したり、不要な最適化をしてしまうことがある(YAGNI 原則だ)

YAGNI 原則（You Aren't Gonna Need It）: 今必要ないものは作らない
簡単な計算（count \* 2 など）はメモ化不要
実際に使われる機能だけを実装する

## 感想

カスタムフックを作成する際の原則や大切なことを理解できた
今までは、ただ量が多いから分離するみたいな気持ちだったが、カスタムフックを作る際にはこのような原則を満たしているかを考えて作りたい
カスタムフックを作りすぎるとコードが追いかけにくくなるかな？と思ったけど、このように適切に作成すればそんなことはなさそうだと思った
