# useReducer

useReducer は React のフック の一つで、複雑な状態管理 を行うために使用される
useState の代替として、より構造化された方法で状態を管理できる

## 基本的な概念

1. Redux パターンの React 版

```javascript
// Redux のパターンを React フックで実現
const [state, dispatch] = useReducer(reducer, initialState);
```

構成要素：

- state: 現在の状態
- dispatch: アクションを送信する関数
- reducer: アクションに基づいて新しい状態を計算する関数
- initialState: 初期状態

2. useState との比較
   useState（シンプルな状態管理）

```javascript
const [count, setCount] = useState(0);

// 状態更新
setCount(count + 1);
setCount((prev) => prev + 1);
```

useReducer（複雑な状態管理）

```javascript
const [state, dispatch] = useReducer(reducer, { count: 0 });

// 状態更新（アクションベース）
dispatch({ type: "INCREMENT" });
dispatch({ type: "DECREMENT" });
dispatch({ type: "SET_VALUE", value: 10 });
```

useReducer の詳細

1. Reducer 関数

```javascript
const reducer = (state, action) => {
  switch (action.type) {
    case "INCREMENT":
      return { count: state.count + 1 };
    case "DECREMENT":
      return { count: state.count - 1 };
    case "SET_VALUE":
      return { count: action.value };
    default:
      return state;
  }
};
```

Reducer の規則：

- 純粋関数: 同じ入力に対して常に同じ出力
- イミュータブル: 元の状態を変更せず、新しい状態を返す
- 副作用なし: API 呼び出しなどの副作用を含まない

2. アクション（Action）

```javascript
// アクションの例
{ type: 'INCREMENT' }
{ type: 'SET_VALUE', value: 42 }
```

アクションの構造：

- type: 何をするかを示す識別子（必須）
- payload: 追加データ（オプション、value, data など任意の名前）

## useReducer の利点：

- 一元化: 複数の関連する状態を 1 つのオブジェクトで管理
- 予測可能性: アクションベースで状態変更が明確
- 型安全性: TypeScript で厳密な型定義が可能
- デバッグしやすい: アクションを記録して状態変更を追跡可能
- テストしやすい: Reducer は純粋関数なので単体テストが簡単

## 実際の使用例

シンプルなカウンター

```javascript
const counterReducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    case "reset":
      return { count: 0 };
    default:
      return state;
  }
};

const Counter = () => {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });

  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: "increment" })}>+</button>
      <button onClick={() => dispatch({ type: "decrement" })}>-</button>
      <button onClick={() => dispatch({ type: "reset" })}>Reset</button>
    </div>
  );
};
```

フォームバリデーション（実際の例）

```javascript
const validationReducer = (state, action) => {
  switch (action.type) {
    case "VALIDATE_EMAIL":
      return {
        ...state,
        email: validateEmail(action.value), // バリデーション関数
      };
    case "VALIDATE_PASSWORD":
      return {
        ...state,
        password: validatePassword(action.value),
      };
    case "RESET_ERRORS":
      return {};
    default:
      return state;
  }
};
```

## useState との使い分け

| 状況                                  | 推奨                 | 理由               |
| ------------------------------------- | -------------------- | ------------------ |
| 単純な状態（boolean, string, number） | useState             | シンプルで十分     |
| 複数の関連する状態                    | useReducer           | 一元管理が可能     |
| 複雑な状態更新ロジック                | useReducer           | アクションで明確化 |
| 状態更新が頻繁                        | useReducer           | パフォーマンス向上 |
| コンポーネント間での状態共有          | useReducer + Context | 構造化された管理   |
