## let の振る舞いについて

- let は遅延評価＋メモ化をする
  最初に呼ばれたときだけブロックが実行され、その同じ example（it）内の再呼び出しは同じオブジェクトが返る。example をまたぐと毎回作り直される。

サンプル

```ruby
$count = 0
RSpec.describe "let" do
  let(:count) { $count += 1 }

  it "memoizes the value" do
    expect(count).to eq(1)
    expect(count).to eq(1)
  end

  it "is not cached across examples" do
    expect(count).to eq(2)
  end
end
```

- `memoizes the value` 内で count が呼び出される
  - 1 回目は当然`1`になる
  - 2 回目はキャッシュされた値が呼び出されるので`1`が返り、テストが通る
- `is not cached across examples` では、また新たに `count` が呼ばれる
  - `memoizes the value` で `$count = 1` になっている状態から +1 されるので 2 になり、テストが通る

let をうまく使えば、example 毎で無駄な計算・参照を減らすことができる！
